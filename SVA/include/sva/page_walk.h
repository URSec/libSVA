/*===- page_walk.h - SVA Execution Engine  =---------------------------------===
 *
 *                        Secure Virtual Architecture
 *
 * Copyright (c) The University of Rochester, 2019.
 * All rights reserved.
 *
 * This file was developed by the LLVM research group and is distributed under
 * the University of Illinois Open Source License. See LICENSE.TXT for details.
 *
 *===------------------------------------------------------------------------===
 *
 * X86 page table walk utilities.
 *
 *===------------------------------------------------------------------------===
 */

#ifndef SVA_PAGE_WALK_H
#define SVA_PAGE_WALK_H

#include <sva/cr.h>
#include <sva/dmap.h>
#include <sva/page.h>

/**
 * Get the currently active root page table pointer.
 *
 * @return  The physical address of the current root page table
 */
static inline uintptr_t get_root_pagetable(void) {
  /* Get the page table value out of CR3 */
  uintptr_t cr3 = read_cr3();

  /*
   * Mask off the flag bits in CR3, leaving just the 4 kB-aligned physical
   * address of the top-level page table.
   */
  return cr3 & PG_FRAME;
}

/**
 * Get the physical address of the L4 page table entry that maps a virtual
 * address.
 *
 * @param cr3   The root page table pointer
 * @param vaddr A virtual address
 * @return      The physical address of the L4 page table entry that maps
 *              `vaddr`
 */
static inline uintptr_t get_pml4ePaddr(cr3_t cr3, uintptr_t vaddr) {
  return (uintptr_t)&((pml4e_t*)(cr3 & PG_FRAME))[PG_L4_ENTRY(vaddr)];
}

/**
 * Get the physical address of the L3 page table entry that maps a virtual
 * address.
 *
 * @param pml4e The L4 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      The physical address of the L3 page table entry that maps
 *              `vaddr`
 */
static inline uintptr_t get_pdptePaddr(pml4e_t pml4e, uintptr_t vaddr) {
  return (uintptr_t)&((pdpte_t*)(pml4e & PG_FRAME))[PG_L3_ENTRY(vaddr)];
}

/**
 * Get the physical address of the L2 page table entry that maps a virtual
 * address.
 *
 * @param pdpte The L3 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      The physical address of the L2 page table entry that maps
 *              `vaddr`
 */
static inline uintptr_t get_pdePaddr(pdpte_t pdpte, uintptr_t vaddr) {
  return (uintptr_t)&((pde_t*)(pdpte & PG_FRAME))[PG_L2_ENTRY(vaddr)];
}

/**
 * Get the physical address of the L1 page table entry that maps a virtual
 * address.
 *
 * @param pde   The L2 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      The physical address of the L1 page table entry that maps
 *              `vaddr`
 */
static inline uintptr_t get_ptePaddr(pde_t pde, uintptr_t vaddr) {
  return (uintptr_t)&((pte_t*)(pde & PG_FRAME))[PG_L1_ENTRY(vaddr)];
}

/**
 * Get a pointer to the L4 page table entry that maps a virtual address.
 *
 * @param cr3   The root page table pointer
 * @param vaddr A virtual address
 * @return      A pointer to the L4 page table entry that maps `vaddr`
 */
static inline pml4e_t* get_pml4eVaddr(cr3_t cr3, uintptr_t vaddr) {
  return (pml4e_t*)getVirtual(get_pml4ePaddr(cr3, vaddr));
}

/**
 * Get a pointer to the L3 page table entry that maps a virtual address.
 *
 * @param pml4e The L4 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      A pointer to the L3 page table entry that maps `vaddr`
 */
static inline pdpte_t* get_pdpteVaddr(pml4e_t pml4e, uintptr_t vaddr) {
  return (pdpte_t*)getVirtual(get_pdptePaddr(pml4e, vaddr));
}

/**
 * Get a pointer to the L2 page table entry that maps a virtual address.
 *
 * @param pml4e The L3 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      A pointer to the L2 page table entry that maps `vaddr`
 */
static inline pde_t* get_pdeVaddr(pdpte_t pdpte, uintptr_t vaddr) {
  return (pde_t*)getVirtual(get_pdePaddr(pdpte, vaddr));
}

/**
 * Get a pointer to the L1 page table entry that maps a virtual address.
 *
 * @param pml4e The L2 page table entry that mapps `vaddr`
 * @param vaddr A virtual address
 * @return      A pointer to the L1 page table entry that maps `vaddr`
 */
static inline pte_t* get_pteVaddr(pde_t pde, uintptr_t vaddr) {
  return (pte_t*)getVirtual(get_ptePaddr(pde, vaddr));
}

/**
 * Perform a page table walk and return pointers to the page table entries in
 * addition to the mapped physical address.
 *
 * This function is designed to perform a page table walk and return any
 * relavant information that is generated by that walk, while gracefully
 * handling any errors. This unfortunately results in a relatively complicated
 * interface which deserves a more in-depth explanation.
 *
 * If `vaddr` is actually mapped to some physical address, then the return value
 * will be positive and will indicate the level of page table at which the leaf
 * entry is found. For example, this will be 1 for a normal page or 2 or 3 for a
 * super page. Additionally, `*paddr` will be written with the virtual address
 * to which `vaddr` mapps.
 *
 * If `vaddr` is not mapped, then the return value will be negative and will
 * indicate the last level page table for which an entry covering `vaddr`
 * exists. In other words, if the L4 and L3 entries mapping `vaddr` are present
 * but the L2 entry is marked not present, then the return value will be -2.
 * Note that the return value may be -5 if it is determined that the root page
 * table pointer doesn't actually point to a valid root page table.
 *
 * In either of these cases, pointers to the page table entries mapping `vaddr`
 * will be written to `*pml4e`, `*pdpte`, `*pde`, and `*pte`, so long as the
 * entry exists. In other words, if the L2 entry is marked not present, then no
 * L1 entry exists, so nothing will be written to `*pte`. Note that `*pde` will
 * still be written with the address of the (not-present) L2 entry.
 *
 * In the edge case where `vaddr` is not a canonical address, the return value
 * will be 0.
 *
 * This function will also perform a page table walk starting at a lower level
 * in the paging hierarchy. If the caller passes an existing page table entry,
 * the walk will start at the lowest level entry which was given. For example,
 * if `pde` and `*pde` are both non-null, then the walk will start with the L2
 * entry `**pde`. In this case, none of the higher-level pages will be examined,
 * and the corresponding pointers to their entries will not be written.
 *
 * Note that there are several wrappers provided for this function to handle
 * common use cases. Due to their simpler interfaces, tt is recommended that you
 * use those whenever possible.
 *
 * @param[in]     cr3   The root page table pointer
 * @param[in]     vaddr The virtual address for which to perform the walk
 * @param[in,out] pml4e The L4 entry mapping `vaddr`
 * @param[in,out] pdpte The L3 entry mapping `vaddr`
 * @param[in,out] pde   The L2 entry mapping `vaddr`
 * @param[in,out] pte   The L1 entry mapping `vaddr`
 * @param[out]    paddr The physical address to which `vaddr` maps
 * @return              If `vaddr` is mapped, the paging level of the leaf
 *                      entry;
 *                      if `vaddr` is not mapped, the negative of the paging
 *                      level of the terminal entry;
 *                      or 0 of `vaddr` is not canonical.
 */
extern int walk_page_table(cr3_t cr3, uintptr_t vaddr, pml4e_t** pml4e,
                           pdpte_t** pdpte, pde_t** pde, pte_t** pte,
                           uintptr_t* paddr);

/**
 * Get the physical address of the specified virtual address using the virtual
 * address space currently in use on this processor.
 *
 * @param vaddr The virtual address for which to query the physical address
 * @return      The physical address to which `vaddr` maps, or PADDR_INVALID if
 *              `vaddr` is unmapped
 */
extern uintptr_t getPhysicalAddr(void* vaddr);

/**
 * Get the physical address of the specified virtual address using the specified
 * L4 pagetable entry.
 *
 * Because we save the L4 entry mapping ghost memory into our thread data, it is
 * common for us to already have the L4 entry when we want to do a walk for a
 * ghost memory address.
 *
 * @param[in]  vaddr  The virtual address to look up
 * @param[in]  pml4e  A pointer to the PML4E entry from which to start the lookup
 * @param[out] paddr  The physical address to which `vaddr` maps
 * @return            True if the walk succeeded, false if it failed (e.g.
 *                    because `vaddr` isn't mapped)
 */
extern bool
getPhysicalAddrFromPML4E(void* vaddr, pml4e_t* pml4e, uintptr_t* paddr);

/**
 * Get the terminal page table entry mapping the specified virtual address.
 *
 * This could be the leaf entry that actually maps the virtual address to a
 * physical address, or it could be the first entry that doesn't have is not
 * present (valid bit unset).
 *
 * @param vaddr The virtual address for which to find the terminal entry
 * @return      A pointer to the terminal page table entry mapping `vaddr`, or
 *              `NULL` if an error was encountered during the page table walk
 */
page_entry_t* get_pgeVaddr(uintptr_t vaddr);

#endif /* SVA_PAGE_WALK_H */
